import Foundation
import Supabase

/// Main authentication service that coordinates platform OAuth with Supabase
class AuthService {
    static let shared = AuthService()

    private let supabase = PhlockSupabaseClient.shared.client

    // Store current user ID locally since we're not using Supabase Auth sessions
    private let userIdKey = "phlock_current_user_id"

    private var currentUserId: UUID? {
        get {
            guard let uuidString = UserDefaults.standard.string(forKey: userIdKey) else { return nil }
            return UUID(uuidString: uuidString)
        }
        set {
            if let newValue = newValue {
                UserDefaults.standard.set(newValue.uuidString, forKey: userIdKey)
            } else {
                UserDefaults.standard.removeObject(forKey: userIdKey)
            }
        }
    }

    private init() {}

    // MARK: - Spotify Authentication Flow

    /// Complete Spotify sign-in flow: OAuth -> fetch data -> create/update Supabase user
    func signInWithSpotify() async throws -> User {
        // Step 1: Authenticate with Spotify
        let authResult = try await SpotifyService.shared.authenticate()

        // Step 2: Fetch user data from Spotify
        let profile = try await SpotifyService.shared.getUserProfile(accessToken: authResult.accessToken)
        let recentlyPlayed = try await SpotifyService.shared.getRecentlyPlayed(accessToken: authResult.accessToken)
        let topArtistsResponse = try await SpotifyService.shared.getTopArtists(accessToken: authResult.accessToken) // short_term (last 4 weeks)

        // Fetch Apple Music IDs for top artists (cross-platform linking)
        let topArtistsWithCrossPlatformIds = await withTaskGroup(of: (String, String, String?, String?).self) { group in
            for artist in topArtistsResponse.items.prefix(10) {
                group.addTask {
                    let appleMusicId = try? await AppleMusicService.shared.searchArtistId(artistName: artist.name)
                    return (artist.id, artist.name, artist.images?.first?.url, appleMusicId)
                }
            }

            var results: [(String, String, String?, String?)] = []
            for await result in group {
                results.append(result)
            }
            return results
        }

        // Step 3: Create or update user in Supabase
        let user = try await createOrUpdateUser(
            platformType: .spotify,
            platformUserId: profile.id,
            email: profile.email,
            displayName: profile.displayName ?? "Spotify User",
            profilePhotoUrl: profile.images?.first?.url,
            platformData: PlatformUserData(
                spotifyEmail: profile.email,
                spotifyDisplayName: profile.displayName,
                spotifyImageUrl: profile.images?.first?.url,
                spotifyCountry: profile.country,
                spotifyProduct: profile.product,
                appleMusicUserId: nil,
                appleMusicStorefront: nil,
                topArtists: topArtistsWithCrossPlatformIds.map {
                    MusicItem(
                        id: $0.0, // Spotify ID
                        name: $0.1,
                        artistName: nil,
                        previewUrl: nil,
                        albumArtUrl: $0.2,
                        isrc: nil,
                        playedAt: nil,
                        spotifyId: $0.0, // Store Spotify ID
                        appleMusicId: $0.3 // Store Apple Music ID (if found)
                    )
                },
                topTracks: recentlyPlayed.items.prefix(20).map {
                    let formatter = ISO8601DateFormatter()
                    formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
                    let playedDate = formatter.date(from: $0.playedAt)
                    if playedDate == nil {
                        print("‚ö†Ô∏è Failed to parse timestamp: \($0.playedAt)")
                    }
                    return MusicItem(
                        id: $0.track.id,
                        name: $0.track.name,
                        artistName: $0.track.artists.first?.name,
                        previewUrl: $0.track.previewUrl,
                        albumArtUrl: $0.track.album.images.first?.url,
                        isrc: $0.track.externalIds?.isrc,
                        playedAt: playedDate
                    )
                },
                recentlyPlayed: recentlyPlayed.items.prefix(20).map {
                    let formatter = ISO8601DateFormatter()
                    formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
                    let playedDate = formatter.date(from: $0.playedAt)
                    return MusicItem(
                        id: $0.track.id,
                        name: $0.track.name,
                        artistName: $0.track.artists.first?.name,
                        previewUrl: $0.track.previewUrl,
                        albumArtUrl: $0.track.album.images.first?.url,
                        isrc: $0.track.externalIds?.isrc,
                        playedAt: playedDate
                    )
                },
                playlists: nil
            )
        )

        // Step 4: Store platform token
        try await storePlatformToken(
            userId: user.id,
            platformType: .spotify,
            accessToken: authResult.accessToken,
            refreshToken: authResult.refreshToken,
            expiresIn: authResult.expiresIn,
            scope: authResult.scope
        )

        // Step 5: Create or link Supabase Auth session
        try await linkToSupabaseAuth(userId: user.id, email: profile.email ?? "noemail@phlock.app")

        // Step 6: Store user ID locally for session persistence
        currentUserId = user.id

        return user
    }

    // MARK: - Apple Music Authentication Flow

    /// Complete Apple Music sign-in flow
    func signInWithAppleMusic() async throws -> User {
        // Step 1: Authenticate with Apple Music
        let authResult = try await AppleMusicService.shared.authenticate()

        // Step 2: Fetch user data from Apple Music
        let topSongs = try await AppleMusicService.shared.getTopSongs()
        let topArtists = try await AppleMusicService.shared.getTopArtists()
        let recentlyPlayedWithArtists = try await AppleMusicService.shared.getRecentlyPlayed()
        let storefront = try await AppleMusicService.shared.getStorefront()

        // Fetch artist artwork and Spotify IDs for top artists (cross-platform linking)
        // Using Supabase Edge Function to keep client secret secure
        let topArtistsWithCrossPlatformData = await withTaskGroup(of: (String, String, String?, String?).self) { group in
            for artist in topArtists {
                group.addTask {
                    let artwork = try? await AppleMusicService.shared.fetchArtistArtwork(artistName: artist.name)
                    let spotifyId = try? await self.searchSpotifyArtist(artistName: artist.name)
                    return (artist.id, artist.name, artwork, spotifyId)
                }
            }

            var results: [(String, String, String?, String?)] = []
            for await result in group {
                results.append(result)
            }
            return results
        }

        // Step 3: Create or update user in Supabase
        // Note: Apple Music doesn't provide email/name directly through MusicKit
        // We'll need to get this from profile setup screen
        let user = try await createOrUpdateUser(
            platformType: .appleMusic,
            platformUserId: authResult.userToken, // Using stable user token as ID
            email: nil, // Will be set during profile setup
            displayName: "Apple Music User", // Will be updated during profile setup
            profilePhotoUrl: nil,
            platformData: PlatformUserData(
                spotifyEmail: nil,
                spotifyDisplayName: nil,
                spotifyImageUrl: nil,
                spotifyCountry: nil,
                spotifyProduct: nil,
                appleMusicUserId: authResult.userToken,
                appleMusicStorefront: storefront,
                topArtists: topArtistsWithCrossPlatformData.map {
                    MusicItem(
                        id: $0.0, // Apple Music ID
                        name: $0.1,
                        artistName: nil,
                        previewUrl: nil,
                        albumArtUrl: $0.2,
                        isrc: nil,
                        playedAt: nil,
                        spotifyId: $0.3, // Store Spotify ID (if found)
                        appleMusicId: $0.0 // Store Apple Music ID
                    )
                },
                topTracks: topSongs.prefix(20).map {
                    MusicItem(
                        id: $0.id,
                        name: $0.title,
                        artistName: $0.artistName,
                        previewUrl: $0.previewURL,
                        albumArtUrl: $0.artworkURL,
                        isrc: nil, // Apple Music doesn't expose ISRC in recently played, we'll get it during catalog search
                        playedAt: nil // Apple Music MusicKit doesn't provide timestamps for top songs
                    )
                },
                recentlyPlayed: recentlyPlayedWithArtists.prefix(20).map {
                    MusicItem(
                        id: $0.track.id,
                        name: $0.track.title,
                        artistName: $0.track.artistName,
                        previewUrl: $0.track.previewURL,
                        albumArtUrl: $0.track.artworkURL,
                        isrc: nil, // Apple Music doesn't expose ISRC in recently played, we'll get it during catalog search
                        playedAt: nil // Apple Music MusicKit doesn't provide timestamps
                    )
                },
                playlists: nil
            )
        )

        // Step 4: Store platform token
        try await storePlatformToken(
            userId: user.id,
            platformType: .appleMusic,
            accessToken: authResult.userToken,
            refreshToken: nil,
            expiresIn: 86400 * 365, // Apple Music tokens last 1 year
            scope: "music"
        )

        // Step 5: Create or link Supabase Auth session
        // Note: Apple Music doesn't provide email, so we'll use a placeholder
        let email = "\(user.id.uuidString)@phlock.app"
        try await linkToSupabaseAuth(userId: user.id, email: email)

        // Step 6: Store user ID locally for session persistence
        currentUserId = user.id

        return user
    }

    // MARK: - User Profile Management

    /// Update user profile after setup screen
    func updateUserProfile(
        userId: UUID,
        displayName: String,
        bio: String?,
        profilePhotoUrl: String?
    ) async throws {
        var updates: [String: String] = [
            "display_name": displayName,
            "updated_at": ISO8601DateFormatter().string(from: Date())
        ]

        if let bio = bio {
            updates["bio"] = bio
        }
        if let profilePhotoUrl = profilePhotoUrl {
            updates["profile_photo_url"] = profilePhotoUrl
        }

        try await supabase
            .from("users")
            .update(updates)
            .eq("id", value: userId.uuidString)
            .execute()
    }

    /// Upload profile photo to Supabase Storage
    func uploadProfilePhoto(userId: UUID, imageData: Data) async throws -> String {
        let fileName = "\(userId.uuidString).jpg"
        let filePath = "profile-photos/\(fileName)"

        // Upload with upsert to replace existing photo
        try await supabase.storage
            .from("profile-photos")
            .upload(
                filePath,
                data: imageData,
                options: FileOptions(
                    contentType: "image/jpeg",
                    upsert: true  // Replace existing file if it exists
                )
            )

        let publicURL = try supabase.storage
            .from("profile-photos")
            .getPublicURL(path: filePath)

        // Add timestamp to bust AsyncImage cache when photo is updated
        let timestamp = Int(Date().timeIntervalSince1970)
        return "\(publicURL.absoluteString)?t=\(timestamp)"
    }

    /// Get current user profile
    func getCurrentUser() async throws -> User? {
        // Use locally stored user ID instead of Supabase Auth session
        guard let userId = currentUserId else {
            return nil
        }

        let response: [User] = try await supabase
            .from("users")
            .select("*")
            .eq("id", value: userId.uuidString)
            .execute()
            .value

        return response.first
    }

    /// Get user by ID and update stored session
    func getUserById(_ userId: UUID) async throws -> User? {
        let response: [User] = try await supabase
            .from("users")
            .select("*")
            .eq("id", value: userId.uuidString)
            .execute()
            .value

        if let user = response.first {
            // Store the user ID for future sessions
            currentUserId = user.id
        }

        return response.first
    }

    // MARK: - Refresh Music Data

    /// Refresh the current user's music data from their streaming platform
    func refreshMusicData() async throws -> User? {
        guard let currentUser = try await getCurrentUser() else {
            print("‚ùå No current user to refresh")
            return nil
        }

        print("üîÑ Refreshing music data for \(currentUser.displayName)")

        let updatedPlatformData: PlatformUserData

        switch currentUser.platformType {
        case .spotify:
            print("üéµ Refreshing Spotify data...")

            // Get access token for Spotify
            guard let accessToken = try await getPlatformAccessToken(userId: currentUser.id, platformType: .spotify) else {
                print("‚ùå No Spotify access token found")
                return currentUser
            }

            // Fetch fresh data from Spotify
            let recentlyPlayed = try await SpotifyService.shared.getRecentlyPlayed(accessToken: accessToken)
            let topArtistsResponse = try await SpotifyService.shared.getTopArtists(accessToken: accessToken)

            // Fetch Apple Music IDs for top artists (cross-platform linking)
            let topArtistsWithCrossPlatformIds = await withTaskGroup(of: (String, String, String?, String?).self) { group in
                for artist in topArtistsResponse.items.prefix(10) {
                    group.addTask {
                        let appleMusicId = try? await AppleMusicService.shared.searchArtistId(artistName: artist.name)
                        return (artist.id, artist.name, artist.images?.first?.url, appleMusicId)
                    }
                }

                var results: [(String, String, String?, String?)] = []
                for await result in group {
                    results.append(result)
                }
                return results
            }

            // Update platform data
            updatedPlatformData = PlatformUserData(
                spotifyEmail: currentUser.platformData?.spotifyEmail,
                spotifyDisplayName: currentUser.platformData?.spotifyDisplayName,
                spotifyImageUrl: currentUser.platformData?.spotifyImageUrl,
                spotifyCountry: currentUser.platformData?.spotifyCountry,
                spotifyProduct: currentUser.platformData?.spotifyProduct,
                appleMusicUserId: currentUser.platformData?.appleMusicUserId,
                appleMusicStorefront: currentUser.platformData?.appleMusicStorefront,
                topArtists: topArtistsWithCrossPlatformIds.map {
                    MusicItem(
                        id: $0.0, // Spotify ID
                        name: $0.1,
                        artistName: nil,
                        previewUrl: nil,
                        albumArtUrl: $0.2,
                        isrc: nil,
                        playedAt: nil,
                        spotifyId: $0.0, // Store Spotify ID
                        appleMusicId: $0.3 // Store Apple Music ID (if found)
                    )
                },
                topTracks: recentlyPlayed.items.prefix(20).map {
                    let formatter = ISO8601DateFormatter()
                    formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
                    let playedDate = formatter.date(from: $0.playedAt)
                    if playedDate == nil {
                        print("‚ö†Ô∏è Failed to parse timestamp: \($0.playedAt)")
                    }
                    return MusicItem(
                        id: $0.track.id,
                        name: $0.track.name,
                        artistName: $0.track.artists.first?.name,
                        previewUrl: $0.track.previewUrl,
                        albumArtUrl: $0.track.album.images.first?.url,
                        isrc: $0.track.externalIds?.isrc,
                        playedAt: playedDate
                    )
                },
                recentlyPlayed: recentlyPlayed.items.prefix(20).map {
                    let formatter = ISO8601DateFormatter()
                    formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
                    let playedDate = formatter.date(from: $0.playedAt)
                    return MusicItem(
                        id: $0.track.id,
                        name: $0.track.name,
                        artistName: $0.track.artists.first?.name,
                        previewUrl: $0.track.previewUrl,
                        albumArtUrl: $0.track.album.images.first?.url,
                        isrc: $0.track.externalIds?.isrc,
                        playedAt: playedDate
                    )
                },
                playlists: currentUser.platformData?.playlists
            )

        case .appleMusic:
            print("üçé Refreshing Apple Music data...")

            // Fetch fresh data from Apple Music
            let topSongs = try await AppleMusicService.shared.getTopSongs()
            let topArtists = try await AppleMusicService.shared.getTopArtists()
            let recentlyPlayedWithArtists = try await AppleMusicService.shared.getRecentlyPlayed()

            // Fetch artist artwork and Spotify IDs for top artists (cross-platform linking)
            // Using Supabase Edge Function to keep client secret secure
            let topArtistsWithCrossPlatformData = await withTaskGroup(of: (String, String, String?, String?).self) { group in
                for artist in topArtists {
                    group.addTask {
                        let artwork = try? await AppleMusicService.shared.fetchArtistArtwork(artistName: artist.name)
                        let spotifyId = try? await self.searchSpotifyArtist(artistName: artist.name)
                        return (artist.id, artist.name, artwork, spotifyId)
                    }
                }

                var results: [(String, String, String?, String?)] = []
                for await result in group {
                    results.append(result)
                }
                return results
            }

            // Update platform data
            updatedPlatformData = PlatformUserData(
                spotifyEmail: currentUser.platformData?.spotifyEmail,
                spotifyDisplayName: currentUser.platformData?.spotifyDisplayName,
                spotifyImageUrl: currentUser.platformData?.spotifyImageUrl,
                spotifyCountry: currentUser.platformData?.spotifyCountry,
                spotifyProduct: currentUser.platformData?.spotifyProduct,
                appleMusicUserId: currentUser.platformData?.appleMusicUserId,
                appleMusicStorefront: currentUser.platformData?.appleMusicStorefront,
                topArtists: topArtistsWithCrossPlatformData.map {
                    MusicItem(
                        id: $0.0, // Apple Music ID
                        name: $0.1,
                        artistName: nil,
                        previewUrl: nil,
                        albumArtUrl: $0.2,
                        isrc: nil,
                        playedAt: nil,
                        spotifyId: $0.3, // Store Spotify ID (if found)
                        appleMusicId: $0.0 // Store Apple Music ID
                    )
                },
                topTracks: topSongs.prefix(20).map {
                    MusicItem(
                        id: $0.id,
                        name: $0.title,
                        artistName: $0.artistName,
                        previewUrl: $0.previewURL,
                        albumArtUrl: $0.artworkURL,
                        isrc: nil,
                        playedAt: nil
                    )
                },
                recentlyPlayed: recentlyPlayedWithArtists.prefix(20).map {
                    MusicItem(
                        id: $0.track.id,
                        name: $0.track.title,
                        artistName: $0.track.artistName,
                        previewUrl: $0.track.previewURL,
                        albumArtUrl: $0.track.artworkURL,
                        isrc: nil,
                        playedAt: nil
                    )
                },
                playlists: currentUser.platformData?.playlists
            )
        }

        // Update user in database
        let updated: User = try await supabase
            .from("users")
            .update(["platform_data": updatedPlatformData])
            .eq("id", value: currentUser.id.uuidString)
            .select()
            .single()
            .execute()
            .value

        print("‚úÖ Music data refreshed successfully")
        return updated
    }

    // MARK: - Sign Out

    func signOut() async throws {
        // Clear locally stored user ID
        currentUserId = nil

        // Try to sign out from Supabase Auth (may not have session, that's ok)
        try? await supabase.auth.signOut()
    }

    // MARK: - Supabase Auth Integration

    /// Link custom user to Supabase Auth by creating or signing into a Supabase Auth account
    private func linkToSupabaseAuth(userId: UUID, email: String) async throws {
        print("üîó Linking user \(userId) to Supabase Auth with email: \(email)")

        // Generate a deterministic password based on user ID so it's the same across devices
        // This allows the user to sign in on multiple devices with the same credentials
        // We don't need users to remember this since they authenticate via OAuth
        let password = "phlock_\(userId.uuidString)_auth_key"

        do {
            // Try to sign up a new Supabase Auth user
            let authResponse = try await supabase.auth.signUp(
                email: email,
                password: password
            )

            let authUserId = authResponse.user.id

            print("‚úÖ Created new Supabase Auth user: \(authUserId)")

            // Link the auth user ID to the custom user record
            try await supabase
                .from("users")
                .update(["auth_user_id": authUserId.uuidString])
                .eq("id", value: userId.uuidString)
                .execute()

            print("‚úÖ Linked custom user \(userId) to auth user \(authUserId)")

        } catch {
            // If sign up fails (e.g., user already exists), try to sign in
            print("‚ö†Ô∏è Sign up failed, trying to sign in: \(error)")

            do {
                let signInResponse = try await supabase.auth.signIn(
                    email: email,
                    password: password
                )

                let authUserId = signInResponse.user.id

                print("‚úÖ Signed in to existing Supabase Auth user: \(authUserId)")

                // Update the link (might already exist, but ensure it's current)
                try await supabase
                    .from("users")
                    .update(["auth_user_id": authUserId.uuidString])
                    .eq("id", value: userId.uuidString)
                    .execute()

                print("‚úÖ Updated link for custom user \(userId) to auth user \(authUserId)")

            } catch let signInError {
                // If sign-in fails with invalid credentials, the password might be outdated
                // Try to update the password using admin edge function, then retry sign-in
                print("‚ö†Ô∏è Sign in failed: \(signInError)")

                // Check if error message contains "Invalid login credentials" or "invalid_credentials"
                let errorDescription = String(describing: signInError)
                print("üîç Full error description: '\(errorDescription)'")
                print("üîç Checking for 'invalid_credentials': \(errorDescription.contains("invalid_credentials"))")
                print("üîç Checking for 'Invalid login credentials': \(errorDescription.contains("Invalid login credentials"))")

                if errorDescription.contains("invalid_credentials") || errorDescription.contains("Invalid login credentials") {

                    print("üîß Invalid credentials detected - attempting password migration")

                    do {
                        // Call edge function to update password
                        struct UpdatePasswordResponse: Decodable {
                            let success: Bool
                            let authUserId: String
                        }

                        let response: UpdatePasswordResponse = try await supabase.functions.invoke(
                            "update-auth-password",
                            options: FunctionInvokeOptions(
                                body: [
                                    "email": email,
                                    "newPassword": password
                                ]
                            )
                        )

                        print("‚úÖ Password migration successful for auth user: \(response.authUserId)")

                        // Now try signing in again with the updated password
                        let retrySignInResponse = try await supabase.auth.signIn(
                            email: email,
                            password: password
                        )

                        let authUserId = retrySignInResponse.user.id

                        print("‚úÖ Signed in after password migration: \(authUserId)")

                        // Update the link
                        try await supabase
                            .from("users")
                            .update(["auth_user_id": authUserId.uuidString])
                            .eq("id", value: userId.uuidString)
                            .execute()

                        print("‚úÖ Updated link for custom user \(userId) to auth user \(authUserId)")

                    } catch {
                        print("‚ùå Password migration failed: \(error)")
                        print("‚ö†Ô∏è User will not be able to access RLS-protected data until linked")
                    }
                } else {
                    print("‚ùå Failed to link to Supabase Auth: \(signInError)")
                    print("‚ö†Ô∏è User will not be able to access RLS-protected data until linked")
                }
            }
        }
    }

    // MARK: - Private Helper Methods

    private func createOrUpdateUser(
        platformType: PlatformType,
        platformUserId: String,
        email: String?,
        displayName: String,
        profilePhotoUrl: String?,
        platformData: PlatformUserData
    ) async throws -> User {
        // Check if user exists
        let existingUsers: [User] = try await supabase
            .from("users")
            .select("*")
            .eq("platform_type", value: platformType.rawValue)
            .eq("platform_user_id", value: platformUserId)
            .execute()
            .value

        // Encode platform data as JSON string
        let platformDataJSON = String(data: try JSONEncoder().encode(platformData), encoding: .utf8) ?? "{}"

        if let existingUser = existingUsers.first {
            // Update existing user - ONLY update platform_data, preserve all user-set profile fields
            let updateData: [String: String] = [
                "platform_data": platformDataJSON,
                "updated_at": ISO8601DateFormatter().string(from: Date())
            ]

            let updatedUsers: [User] = try await supabase
                .from("users")
                .update(updateData)
                .eq("id", value: existingUser.id.uuidString)
                .select("*")
                .execute()
                .value

            guard let user = updatedUsers.first else {
                throw AuthError.userUpdateFailed
            }
            return user
        } else {
            // Create new user
            var insertData: [String: String] = [
                "platform_type": platformType.rawValue,
                "platform_user_id": platformUserId,
                "display_name": displayName,
                "platform_data": platformDataJSON
            ]

            if let email = email {
                insertData["email"] = email
            }
            if let profilePhotoUrl = profilePhotoUrl {
                insertData["profile_photo_url"] = profilePhotoUrl
            }

            let newUsers: [User] = try await supabase
                .from("users")
                .insert(insertData)
                .select("*")
                .execute()
                .value

            guard let user = newUsers.first else {
                throw AuthError.userCreationFailed
            }
            return user
        }
    }

    private func getPlatformAccessToken(userId: UUID, platformType: PlatformType) async throws -> String? {
        struct TokenResponse: Codable {
            let accessToken: String

            enum CodingKeys: String, CodingKey {
                case accessToken = "access_token"
            }
        }

        let response: [TokenResponse] = try await supabase
            .from("platform_tokens")
            .select()
            .eq("user_id", value: userId.uuidString)
            .eq("platform_type", value: platformType.rawValue)
            .order("created_at", ascending: false)
            .limit(1)
            .execute()
            .value

        return response.first?.accessToken
    }

    private func storePlatformToken(
        userId: UUID,
        platformType: PlatformType,
        accessToken: String,
        refreshToken: String?,
        expiresIn: Int,
        scope: String
    ) async throws {
        let expiresAt = Date().addingTimeInterval(TimeInterval(expiresIn))

        var tokenData: [String: String] = [
            "user_id": userId.uuidString,
            "platform_type": platformType.rawValue,
            "access_token": accessToken,
            "token_expires_at": ISO8601DateFormatter().string(from: expiresAt),
            "scope": scope
        ]

        if let refreshToken = refreshToken {
            tokenData["refresh_token"] = refreshToken
        }

        try await supabase
            .from("platform_tokens")
            .insert(tokenData)
            .execute()
    }

    /// Search for a Spotify artist using the Supabase Edge Function
    /// This keeps the Spotify client secret secure on the server side
    private func searchSpotifyArtist(artistName: String) async throws -> String? {
        print("üîç Searching for Spotify artist via Edge Function: \(artistName)")

        struct SearchResponse: Decodable {
            let spotifyId: String?
        }

        do {
            // Call Supabase Edge Function with generic response type
            let response: SearchResponse = try await supabase.functions.invoke(
                "search-spotify-artist",
                options: FunctionInvokeOptions(body: ["artistName": artistName])
            )

            if let spotifyId = response.spotifyId {
                print("‚úÖ Found Spotify ID via Edge Function: \(spotifyId)")
                return spotifyId
            }

            print("‚ö†Ô∏è No Spotify artist found via Edge Function")
            return nil
        } catch {
            print("‚ùå Error searching for Spotify artist: \(error)")
            return nil
        }
    }
}

// MARK: - Errors

enum AuthError: LocalizedError {
    case userCreationFailed
    case userUpdateFailed
    case profileUploadFailed

    var errorDescription: String? {
        switch self {
        case .userCreationFailed:
            return "Failed to create user profile"
        case .userUpdateFailed:
            return "Failed to update user profile"
        case .profileUploadFailed:
            return "Failed to upload profile photo"
        }
    }
}
